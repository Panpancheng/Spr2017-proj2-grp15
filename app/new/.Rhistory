load("/Users/chenyun/Desktop/GR5243/Spr2017-proj2-grp15/output/workspace1.RData")
shiny::runApp()
library(plotly)
runApp()
library(leaflet)
runApp()
#Inputs
#w:  w[1:d] is the normal vector of a hyperplane,
#    w[d+1] = -c is the negative offset parameter.
#n: sample size
#Outputs
#S: n by (d+1) sample matrix with last col 1
#y: vector of the associated class labels
fakedata <- function(w, n){
if(! require(MASS))
{
install.packages("MASS")
}
if(! require(mvtnorm))
{
install.packages("mvtnorm")
}
require(MASS)
require(mvtnorm)
# obtain dimension
d <- length(w)-1
# compute the offset vector and a Basis consisting of w and its nullspace
offset <- -w[length(w)] * w[1:d] / sum(w[1:d]^2)
Basis <- cbind(Null(w[1:d]), w[1:d])
# Create samples, correct for offset, and extend
# rmvnorm(n,mean,sigme) ~ generate n samples from N(0,I) distribution
S <- rmvnorm(n, mean=rep(0,d),sigma = diag(1,d)) %*%  t(Basis)
S <- S + matrix(rep(offset,n),n,d,byrow=T)
S <- cbind(S,1)
# compute the class assignments
y <- as.vector(sign(S %*% w))
# add corrective factors to points that lie on the hyperplane.
S[y==0,1:d] <- S[y==0,1:d] + runif(1,-0.5,0.5)*10^(-4)
y = as.vector(sign(S %*% w))
return(list(S=S, y=y))
} # end function fakedata
classify <- function(S,z){
n <- nrow(S[[1]])
y <- NULL
for (i in 1:n){
x <- S[[1]][i,]
ifelse(t(z) %*% x > 0, y[i] <- 1, y[i] <- -1)
}
return (y)
}
perceptrain <- function(S, y){
n <- nrow(S[[1]])
m <- ncol(S[[1]])
# initial z
z <- rnorm(m)
Z_history <- rbind(matrix(ncol = m, nrow = 0), z)
for (k in 1:100000){
Cp <- 0
gdCp <- 0
for (i in 1:n){
x <- S[[1]][i,]
if (sign(y[i]) != sign(z %*% x)){
Cp <- Cp + abs(z %*% x)
gdCp <- gdCp + (-y[i]) %*% x
}
}
if (Cp == 0){
Z_history <- rbind(Z_history, z)
return(list(z = z, Z_history = Z_history))
}
else{
z <- z - (1/k) * gdCp
Z_history <- rbind(Z_history, z)
}
}
}
z <- rnorm(3)
train <- fakedata(z, 100)
test <- fakedata(z, 100)
train.classify<- classify(train, z)
test.classify <- classify(test, z)
percep.train <- perceptrain(train, train.classify)
percep.test <- perceptrain(test, test.classify)
# plotting training data with lines from Z history
library(ggplot2)
train.classified <- cbind(train[[1]], train[[2]])
new.train.classified <- as.data.frame(train.classified)
draw <- ggplot(data = new.train.classified,
aes(x = V1, y = V2, color = V4)) +
geom_point() +
ggtitle("Plot of Training Data and Z History")
draw
n <- nrow(percep.train[[2]])
for (i in 1:nrow(percep.train[[2]])){
norm.mat <- 1/(sqrt(percep.train[[2]][i,1]^2 +
percep.train[[2]][i,2]^2)) * percep.train[[2]][i,]
z.coord <- Null(norm.mat[1:2]) +
norm.mat[3] * c(norm.mat[1], norm.mat[2])
if (i < nrow(percep.train[[2]])){
b <- (Null(norm.mat)[2])/(Null(norm.mat)[1])
draw <- draw +
geom_abline(intercept = -sign(norm.mat[2]) *
norm.mat[3] * sqrt(b^2+1),
slope = b, alpha = 0.3, color = "blue")
} else{
draw <- draw +
geom_abline(intercept = -sign(norm.mat[2]) *
norm.mat[3] * sqrt(b^2+1),
slope = b, color = "black")
}
}
draw
# Plot test data with hyperplane
test.classified <- cbind(test[[1]], test[[2]])
new.test.classified <- as.data.frame(test.classified)
n <- nrow(percep.test[[2]])
new.norm.mat <- 1/(sqrt(percep.test[[2]][n,1]^2 +
percep.test[[2]][n,2]^2)) *
percep.test[[2]][n,]
z.coord2 <- Null(new.norm.mat[1:2]) +
new.norm.mat[3] * c(new.norm.mat[1], new.norm.mat[2])
b <- (Null(new.norm.mat)[2])/(Null(new.norm.mat)[1])
ggplot(data = new.test.classified, aes(x = V1, y =V2, color = V4)) +
geom_point()+
ggtitle("Plot of Test Data and the Classifier Hyperplane") +
geom_abline(intercept = -sign(new.norm.mat[2]) *
new.norm.mat[3] * sqrt(b^2+1),
slope = b, color = "red")
?require
load("/Users/chenyun/Desktop/GR5243/Spr2017-proj2-grp15/output/workspace1.RData")
View(t.schools2014)
t.schools2014 <- t(schools2014)[-1,]
schools2014 <- agg1[agg1$Group.1 == "2014",]
t.schools2014 <- t(schools2014)[-1,]
colnames(t.schools2014) <- as.character(t.schools2014[1,])
d.schools <- ldply(schools)
library(plyr)
library(plyr)
library(dplyr)
d.schools <- ldply(schools)
library(plyr)
d.schools <- ldply(schools)
